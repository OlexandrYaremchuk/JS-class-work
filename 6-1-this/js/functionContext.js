// Контекст стрілки

// Контекст в середині стрілки визначається місцем її оголошення, а не виклику, та посилається на контекст батьківської функції

// Що ми маємо знати.Стрілка немає свого this тобто значення внутрішнього контексту або іншими словами this визначається не в момент виклику йункції, а в момент оголошення. Тобто навпаки від звичайної функції. Там де ми її обявили такий контекст вона запамятає назавжди.

const showThis = () => {
    console.log('this in showThis:', this);
};
showThis(); // ми отримуємо андефайн

// тепер давайте створимо обʼєкт
const user = { name: 'Mango' };
// додамо в обʼєкт новий ключ showContext, як властивість передами йому showThis
user.showContext = showThis;

// і викличемо її
user.showContext();

// В нашому випадку функція була оголошена глобально. Тому this в неї завжди буде andefined. Якщо вона буде оголошена, я метод, відповідно в момент її оголошення вона візьме this  обʼєкта
// Потренуємось.

const user1 = {
    fullname: 'Mango',
    showName() {
        console.log('this:', this);
        console.log(('this.fullName:', this.fullname));

        // тепер створимо звичайну функцію.
        const inner = function () {
            console.log('this is inner:', this);
        };
        inner(); // викликаємо її і бачимо що в консолі андефіне. Все вірно, ми її викликали без контексту. Перед inner не ставили this, Відповідно this і андефіне
        // А от якщо ми в inner оголосимо її як стрілочну функцію, і вона запамятає контекст при її оголошенні, вона покаже нам this.
        // const inner = () => {
        //     console.log('this is inner:', this);
        // };
        // inner();
    },
};
user1.showName(); // все працює все пракрасно, так як це звичайний метод обʼєкта

//* Стрілки, як методи обʼєкта. Точніше сказати, ніколи не використовуйте стрілки, як методи обʼєкта.
const user2 = {
    fullname: 'Mango',
    showName() {
        // додамо стрілку  і отримаємо помилку. Стрілка ніколи не може бути методом обʼєкта
        // це теж саме що і showName: function(){}
        console.log('this:', this);
        console.log(('this.fullName:', this.fullname));
    },
};
user2.showName();
